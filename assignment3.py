# -*- coding: utf-8 -*-
"""Assignment3

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hIC5fU20e3zU2XZf-4SdMJMTzu6Kv7YB
"""

!pip install torch==1.11.0+cu102 torchvision==0.12.0+cu102 torchaudio==0.11.0 --extra-index-url https://download.pytorch.org/whl/cu102

import torch
import torch.nn as nn
import torch.nn.functional as F
from torchvision import datasets
from torchvision.transforms import ToTensor
from torch.utils.data import DataLoader

dataset = datasets.MNIST(root ='./ data ', train = True, download = True,
                         transform = ToTensor())
trainset, valset = torch.utils.data.random_split(dataset, [0.8, 0.2])
testset = datasets.MNIST(root ='./ data ', train = False, download = True,
                         transform = ToTensor())

batch_size = 64
train_loader = DataLoader(trainset, batch_size = batch_size, shuffle = True)
val_loader = DataLoader(valset, batch_size = batch_size, shuffle = False)
test_loader = DataLoader(testset, batch_size = batch_size, shuffle = False)

"""Model"""

class CNN(nn.Module):
  def __init__(self):
    super(CNN, self).__init__()
    self.conv1 = nn.Conv2d(1,64,kernel_size = 3, stride = 1, padding = 1)
    self.conv2 = nn.Conv2d(64,64,kernel_size = 3, stride = 1, padding = 1)
    self.conv3 = nn.Conv2d(64,64,kernel_size = 3, stride = 1, padding = 1)
    self.conv4 = nn.Conv2d(64,64,kernel_size = 3, stride = 1, padding = 1)

    self.bn1 = nn.BatchNorm2d(64)
    self.bn2 = nn.BatchNorm2d(64)
    self.bn3 = nn.BatchNorm2d(64)
    self.bn4 = nn.BatchNorm2d(64)

    self.relu = nn.ReLU()
    self.maxPool = nn.MaxPool2d(2, stride = 2)
    self.flatten = nn.Flatten()

    self.fc = nn.Linear(64, 10)

  def forward(self, x):
    x = self.maxPool(self.relu(self.bn1(self.conv1(x))))
    x = self.maxPool(self.relu(self.bn2(self.conv2(x))))
    x = self.maxPool(self.relu(self.bn3(self.conv3(x))))
    x = self.maxPool(self.relu(self.bn4(self.conv4(x))))
    x = self.flatten(x)
    x = self.fc(x)
    return x

model = CNN()
lossFunction = nn.CrossEntropyLoss()

learning_rate = 0.001
optimizer = torch.optim.SGD(model.parameters(), learning_rate)

"""Training function"""

def train (train_loader, model, lossFunction, optimizer):
  model.train()
  train_size = len(train_loader.dataset)
  train_loss = 0
  train_correct = 0
  for batch, (X,y) in enumerate(train_loader):
    pred = model(X)
    loss = lossFunction(pred, y)
    train_loss += loss.item()
    train_correct += (pred.argmax(1) == y).type(torch.float).sum().item()

    loss.backward()
    optimizer.step()
    optimizer.zero_grad()

    if batch % 200 == 0:
      lossItem = loss.item()
      current = (batch + 1) * len(X)
      print(f"loss: {loss:>3f}  [{current:5d}/{train_size:>5d}]")

  train_loss /= len(train_loader)
  train_correct /= len(train_loader.dataset)
  print(f"Train: Accuracy: {(100*train_correct):>0.1f}%, Avg loss: {train_loss:>6f} \n")

"""Validation function"""

def val (val_loader,model, lossFunction):
  model.eval()

  val_loss = 0
  val_correct = 0

  with torch.no_grad():
    for X, y in val_loader:
      val_pred = model(X)
      val_loss += lossFunction(val_pred, y).item()
      val_correct += (val_pred.argmax(1) == y).type(torch.float).sum().item()

  val_loss /= len(val_loader)
  val_correct /= len(val_loader.dataset)
  print(f"Validation: Accuracy: {(100*val_correct):>0.1f}%, Avg loss: {val_loss:>6f} \n")

"""Test function"""

def test (test_loader,model, lossFunction):
  model.eval()
  test_loss = 0
  test_correct = 0

  with torch.no_grad():
    for X, y in test_loader:
      pred = model(X)
      test_loss += lossFunction(pred, y).item()
      test_correct += (pred.argmax(1) == y).type(torch.float).sum().item()

  test_loss /= len(test_loader)
  test_correct /= len(test_loader.dataset)
  print(f"Test: Accuracy: {(100*test_correct):>0.1f}%, Avg loss: {test_loss:>6f} \n")

epochs = 5
for epoch in range (epochs):
  print(f"With epoch {epoch}: ")
  train(train_loader, model, lossFunction, optimizer)
  val(val_loader, model, lossFunction)
print("Finish training!")
test(test_loader, model, lossFunction)

