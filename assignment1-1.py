# -*- coding: utf-8 -*-
"""Assignment1

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1e3nMVkJAWJt6PiFWGW7wPgnxHCM6vqJp
"""

!pip install torch==1.11.0+cu102 torchvision==0.12.0+cu102 torchaudio==0.11.0 --extra-index-url https://download.pytorch.org/whl/cu102

import torch
import numpy as np
from torchvision import datasets

trainset = datasets.MNIST(root ='./ data ', train =True, download = True)
testset = datasets.MNIST(root ='./ data ', train =False, download = True)

# Indices for train /val splits: train_idx, valid_idx
np.random.seed(0)
val_ratio = 0.1
train_size = len(trainset)
indices = list (range(train_size ))
split_idx = int(np.floor(val_ratio * train_size))

np.random.shuffle(indices)
train_idx, val_idx = indices[split_idx:], indices[:split_idx]
train_data = trainset.data[train_idx].float()/255.
train_labels = trainset.targets[train_idx]
val_data = trainset.data[val_idx].float()/255.
val_labels = trainset.targets[val_idx]
test_data = testset.data.float()/255.
test_labels = testset.targets

"""# **Training and validation code**"""

train_data_flatten = torch.flatten(train_data, start_dim= 1)
val_data_flatten = torch.flatten(val_data, start_dim = 1)
test_data_flatten = torch.flatten(test_data, start_dim = 1)

p = 1
distances = torch.cdist(val_data_flatten,train_data_flatten, p)
for k in range (5, 20):
  top_values, top_indices = torch.topk(distances, k = k, dim = 1, largest = False)
  train_labels[top_indices]
  mode, count = torch.mode(train_labels[top_indices])
  val_pred = mode
  val_pred == val_labels
  num_true = torch.sum(val_pred == val_labels)
  val_acc = (num_true / val_data.shape[0])
  print("p: {:<10} k: {:<10} val_acc: {:.4f}".format(p, k, round(val_acc.item(), 4)))

p = 2
distances = torch.cdist(val_data_flatten,train_data_flatten, p)
for k in range (5, 20):
  top_values, top_indices = torch.topk(distances, k = k, dim = 1, largest = False)
  train_labels[top_indices]
  mode, count = torch.mode(train_labels[top_indices])
  val_pred = mode
  val_pred == val_labels
  num_true = torch.sum(val_pred == val_labels)
  val_acc = (num_true / val_data.shape[0])
  print("p: {:<10} k: {:<10} val_acc: {:.4f}".format(p, k, round(val_acc.item(), 4)))

"""## **Evaluation code of the test set**"""

best_k = 5
best_p = 2

distances = torch.cdist(test_data_flatten,train_data_flatten, p = best_p)
top_values, top_indices = torch.topk(distances, k = best_k, dim = 1, largest = False)
train_labels[top_indices]
mode, count = torch.mode(train_labels[top_indices])
test_pred = mode
test_pred == test_labels
num_true = torch.sum(test_pred == test_labels)
test_acc = num_true / test_data.shape[0]
print("p: {:<10} k: {:<10} test_acc: {:.4f}".format(best_p, best_k, round(test_acc.item(), 4)))